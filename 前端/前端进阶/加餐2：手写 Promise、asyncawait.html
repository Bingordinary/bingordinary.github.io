<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>加餐2：手写 Promise、async/await</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.d7966440.css" as="style"><link rel="preload" href="/assets/js/app.5d177364.js" as="script"><link rel="preload" href="/assets/js/7.65eecb72.js" as="script"><link rel="preload" href="/assets/js/2.aee3cbc0.js" as="script"><link rel="preload" href="/assets/js/14.10728167.js" as="script"><link rel="prefetch" href="/assets/js/1.ffc17af2.js"><link rel="prefetch" href="/assets/js/10.e40fa205.js"><link rel="prefetch" href="/assets/js/11.998b45cb.js"><link rel="prefetch" href="/assets/js/12.a6644bfd.js"><link rel="prefetch" href="/assets/js/13.aa48ab66.js"><link rel="prefetch" href="/assets/js/15.eb51acf3.js"><link rel="prefetch" href="/assets/js/16.89f0606c.js"><link rel="prefetch" href="/assets/js/17.6b9e5670.js"><link rel="prefetch" href="/assets/js/18.0f9d8e12.js"><link rel="prefetch" href="/assets/js/19.73f670cd.js"><link rel="prefetch" href="/assets/js/20.80c71d34.js"><link rel="prefetch" href="/assets/js/21.ce461a5d.js"><link rel="prefetch" href="/assets/js/22.dd95377b.js"><link rel="prefetch" href="/assets/js/23.d79f6c2a.js"><link rel="prefetch" href="/assets/js/24.02efca87.js"><link rel="prefetch" href="/assets/js/25.a9576179.js"><link rel="prefetch" href="/assets/js/26.42612b9c.js"><link rel="prefetch" href="/assets/js/27.4c147396.js"><link rel="prefetch" href="/assets/js/28.e551b06d.js"><link rel="prefetch" href="/assets/js/29.61cdd6e0.js"><link rel="prefetch" href="/assets/js/30.900ceea0.js"><link rel="prefetch" href="/assets/js/31.762721a1.js"><link rel="prefetch" href="/assets/js/32.ae49dc52.js"><link rel="prefetch" href="/assets/js/33.3de563d4.js"><link rel="prefetch" href="/assets/js/34.4f711dd1.js"><link rel="prefetch" href="/assets/js/35.8e5f4086.js"><link rel="prefetch" href="/assets/js/36.2ecb0f42.js"><link rel="prefetch" href="/assets/js/37.25ec0333.js"><link rel="prefetch" href="/assets/js/38.82d1b223.js"><link rel="prefetch" href="/assets/js/39.41ef87dd.js"><link rel="prefetch" href="/assets/js/4.6cc43166.js"><link rel="prefetch" href="/assets/js/40.5fac40cb.js"><link rel="prefetch" href="/assets/js/41.d88af15b.js"><link rel="prefetch" href="/assets/js/5.0398e8cf.js"><link rel="prefetch" href="/assets/js/6.ad5382fd.js"><link rel="prefetch" href="/assets/js/8.27af0ed3.js"><link rel="prefetch" href="/assets/js/9.0a374934.js">
    <link rel="stylesheet" href="/assets/css/0.styles.d7966440.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1c7ddcd9><div class="page-container" data-v-3a89ef20 data-v-1c7ddcd9><div class="header-container" data-v-7c3c8721 data-v-3a89ef20><div class="header-body" data-v-7c3c8721><div class="logoContainer" data-v-7c3c8721><a href="/" data-v-7c3c8721><img src="/image/logo.png" alt="logo" class="logo" data-v-7c3c8721></a></div> <div class="navigation" data-v-7c3c8721><div aria-label="Breadcrumb" role="navigation" class="el-breadcrumb" data-v-7c3c8721><span class="el-breadcrumb__item" data-v-7c3c8721><span role="link" class="el-breadcrumb__inner"><a href="/" data-v-7c3c8721>首页</a></span><span role="presentation" class="el-breadcrumb__separator"></span></span><span class="el-breadcrumb__item" data-v-7c3c8721><span role="link" class="el-breadcrumb__inner"><a href="/ABOUT%20ME.html" data-v-7c3c8721>ABOUT ME</a></span><span role="presentation" class="el-breadcrumb__separator"></span></span><span class="el-breadcrumb__item" data-v-7c3c8721><span role="link" class="el-breadcrumb__inner"><a href="/Linux/" data-v-7c3c8721>Linux</a></span><span role="presentation" class="el-breadcrumb__separator"></span></span><span class="el-breadcrumb__item" data-v-7c3c8721><span role="link" class="el-breadcrumb__inner"><a href="/前端/" data-v-7c3c8721>前端</a></span><span role="presentation" class="el-breadcrumb__separator"></span></span> <span class="el-breadcrumb__item slogan" data-v-7c3c8721><span role="link" class="el-breadcrumb__inner">to be continued...</span><span role="presentation" class="el-breadcrumb__separator"></span></span></div></div></div></div> <div class="body" data-v-3a89ef20><div class="content" data-v-3a89ef20><div class="article" data-v-3a89ef20><div class="content__default" data-v-3a89ef20><h1 id="加餐2-手写-promise、async-await"><a href="#加餐2-手写-promise、async-await" class="header-anchor">#</a> 加餐2：手写 Promise、async/await</h1> <p>Promise、async/await 已经逐渐成为主流的异步处理方式，所以了解其实现原理非常重要。这一课时我们就来讲讲 Promise 和 async/await 的实现。</p> <h3 id="promise-a-规范"><a href="#promise-a-规范" class="header-anchor">#</a> Promise/A+ 规范</h3> <p>在编写 Promise 之前，我们必须了解 Promise/A+ 规范。由于内容较长，下面我总结了几点，更详细的内容可以查阅 <a href="https://promisesaplus.com/" target="_blank" rel="noopener noreferrer">Promise/A+ 规范<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>Promise 是一个对象或者函数，对外提供了一个 then 函数，内部拥有 3 个状态。</p> <h4 id="then-函数"><a href="#then-函数" class="header-anchor">#</a> then 函数</h4> <p>then 函数接收两个函数作为可选参数：</p> <p>复制</p> <div class="language-js extra-class"><pre class="language-js"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>onFulfilled<span class="token punctuation">,</span> onRejected<span class="token punctuation">)</span>
</code></pre></div><p>同时遵循下面几个规则：</p> <ul><li>如果可选参数不为函数时应该被忽略；</li> <li>两个函数都应该是异步执行的，即放入事件队列等待下一轮 tick，而非立即执行；</li> <li>当调用 onFulfilled 函数时，会将当前 Promise 的值作为参数传入；</li> <li>当调用 onRejected 函数时，会将当前 Promise 的失败原因作为参数传入；</li> <li>then 函数的返回值为 Promise。</li></ul> <h4 id="promise-状态"><a href="#promise-状态" class="header-anchor">#</a> Promise 状态</h4> <p>Promise 的 3 个状态分别为 pending、fulfilled 和 rejected。</p> <ul><li>pending：“等待”状态，可以转移到 fulfilled 或者 rejected 状态</li> <li>fulfilled：“执行”（或“履行”）状态，是 Promise 的最终态，表示执行成功，该状态下不可再改变。</li> <li>rejected：“拒绝”状态，是 Promise 的最终态，表示执行失败，该状态不可再改变。</li></ul> <h4 id="promise-解决过程"><a href="#promise-解决过程" class="header-anchor">#</a> Promise 解决过程</h4> <p>Promise 解决过程是一个抽象的操作，即接收一个 promise 和一个值 x，目的就是对 Promise 形式的执行结果进行统一处理。需要考虑以下 3 种情况。</p> <p><strong>情况 1： x 等于 promise</strong></p> <p>抛出一个 TypeError 错误，拒绝 promise。</p> <p><strong>情况 2：x 为 Promise 的实例</strong></p> <p>如果 x 处于等待状态，那么 promise 继续等待至 x 执行或拒绝，否则根据 x 的状态执行/拒绝 promise。</p> <p><strong>情况 3：x 为对象或函数</strong></p> <p>该情况的核心是取出 x.then 并调用，在调用的时候将 this 指向 x。将 then 回调函数中得到结果 y 传入新的 Promise 解决过程中，形成一个递归调用。其中，如果执行报错，则以对应的错误为原因拒绝 promise。</p> <p>这一步是处理拥有 then() 函数的对象或函数，这类对象或函数我们称之为“thenable”。注意，它只是拥有 then() 函数，并不是 Promise 实例。</p> <p><strong>情况 4：如果 x 不为对象或函数</strong></p> <p>以 x 作为值，执行 promise。</p> <h3 id="promise-实现"><a href="#promise-实现" class="header-anchor">#</a> Promise 实现</h3> <p>下面我们就根据规范来逐步实现一个 Promise。</p> <h4 id="promise-函数及状态"><a href="#promise-函数及状态" class="header-anchor">#</a> Promise() 函数及状态</h4> <p>由于 Promise 只有 3 个 状态，这里我们可以先创建 3 个“常量”来消除魔术字符串：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>
<span class="token keyword">var</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>
<span class="token keyword">var</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> 'rejected
</code></pre></div><p>由于 Promise 可以被实例化，所以可以定义成类或函数，这里为了增加难度，先考虑在 ES5 环境下实现，所以写成构造函数的形式。</p> <p>使用过 Promise 的人肯定知道，在创建 Promise  的时候会传入一个回调函数，该回调函数会接收两个参数，分别用来执行或拒绝当前 Promise。同时考虑到 Promise  在执行时可能会有返回值，在拒绝时会给出拒绝原因，我们分别用 value 和 reason 两个变量来表示。具体代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token parameter">execute</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  self<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">PENDING</span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      self<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">FULFILLED</span><span class="token punctuation">;</span>
      self<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      self<span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token constant">REJECTED</span><span class="token punctuation">;</span>
      self<span class="token punctuation">.</span>reason <span class="token operator">=</span> reason<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token function">execute</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们在第 09 课时中提过，Promise 是单次执行的，所以需要判断状态为 PENDING 的时候再执行函数 resolve() 或函数 reject() 。同时 Promise 的内部异常不能直接抛出，所以要进行异常捕获。</p> <h4 id="then-函数-2"><a href="#then-函数-2" class="header-anchor">#</a> then() 函数</h4> <p>每个 Promise 实例都有一个 then() 函数，该函数会访问 Promise 内部的值或拒绝原因，所以通过函数原型 prototype 来实现。then() 函数接收两个回调函数作为参数，于是写成下面的形式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">then</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">onFulfilled<span class="token punctuation">,</span> onRejected</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>根据第 1 条原则，如果可选参数不为函数时应该被忽略，所以在函数 then() 内部加上对参数的判断：</p> <div class="language-js extra-class"><pre class="language-js"><code>onFulfilled <span class="token operator">=</span> <span class="token keyword">typeof</span> onFulfilled <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">?</span> <span class="token function-variable function">onFulfilled</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x
<span class="token punctuation">}</span><span class="token punctuation">;</span>
onRejected <span class="token operator">=</span> <span class="token keyword">typeof</span> onRejected <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span> <span class="token operator">?</span> <span class="token function-variable function">onRejected</span> <span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> e
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>根据第 2 条规则，传入的回调函数是异步执行的。要模拟异步，可以通过 setTimeout  来延迟执行。再根据第 3 条和第 4 条规则，应根据 Promise 的状态来执行对应的回调，执行状态下调用 onFulfilled()  函数，拒绝状态下调用 onRejected() 函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token constant">FULFILLED</span><span class="token operator">:</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">onFulfilled</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> <span class="token constant">REJECTED</span><span class="token operator">:</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">onRejected</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token keyword">case</span> <span class="token constant">PENDING</span><span class="token operator">:</span>
    <span class="token comment">// todo</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>等待状态下就有些麻烦了，需要等到 Promise 状态转变时才能调用。</p> <p>按照常规处理方式，可以建立一个监听，监听 Promise 的状态值改变。由于浏览器环境和 Node.js 环境的事件监听不一样，考虑兼容性，这种实现会比较复杂。</p> <p>换个角度来看，在不考虑异常的情况下 Promise 的状态改变只依赖于构造函数中的  resolve() 函数和 reject() 函数执行。所以可考虑将 onFulfilled() 和 onRejected() 函数先保存到  Promise 属性 onFulfilledFn 和 onRejectedFn 中，等到状态改变时再调用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">case</span> <span class="token constant">PENDING</span><span class="token operator">:</span>
  self<span class="token punctuation">.</span><span class="token function-variable function">onFulfilledFn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onFulfilled</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  self<span class="token punctuation">.</span><span class="token function-variable function">onRejectedFn</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">onRejected</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre></div><p>最后看第 5 条规则，then() 被调用时应该返回一个新的 Promise，所以在上面的 3 种状态的处理逻辑中，都应该创建并返回一个 Promise 实例。以执行状态为例，可以改成下面的样子。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">case</span> <span class="token constant">FULFILLED</span><span class="token operator">:</span>
  promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">onFulfilled</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre></div><p>同时，它带来的另一个效果是<strong>支持链式调用</strong>。在链式调用的情况下，如果 Promise 实例处于等待状态，那么需要保存多个 resolve() 或 reject() 函数，所以 onFulfilledFn 和 onRejectedFn 应该改成数组。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">case</span> <span class="token constant">PENDING</span><span class="token operator">:</span>
  promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    self<span class="token punctuation">.</span>onFulfilledFn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">onFulfilled</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    self<span class="token punctuation">.</span>onRejectedFn<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">onRejected</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>reason<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre></div><p>对应的，Promise 构造函数中应该初始化属性 onFulfilledFn 和 onRejectedFn 为数组，同时 resolve() 和 reject()  函数在改变状态时应该调用这个数组中的函数，并且这个调用过程应该是异步的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Promise</span><span class="token punctuation">(</span><span class="token parameter">execute</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  self<span class="token punctuation">.</span>onFulfilledFn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  self<span class="token punctuation">.</span>onRejectedFn <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token operator">...</span>
  <span class="token keyword">function</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
      self<span class="token punctuation">.</span>onFulfilledFn<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">f</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">...</span>
      self<span class="token punctuation">.</span>onRejectedFn<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">f</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="resolvepromise-函数"><a href="#resolvepromise-函数" class="header-anchor">#</a> resolvePromise() 函数</h4> <p>前面提到解决过程函数有两个参数及 3 种情况，先来考虑第 1 种情况，promise 与 x 相等，应该直接抛出 TypeError 错误：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">promise<span class="token punctuation">,</span> x</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>promise <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">&quot;x 不能与 promise 相等&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>情况 2，x 为 Promise 的实例，应该尝试让 promise 接受 x 的状态，怎么接受呢？</p> <p>直接改变 promise 状态肯定是不可取的，首先状态信息属于内部变量，其次也无法调用属性  onResolvedFn 和 onFulfilledFn 中的待执行函数。所以必须要通过调用 promise 在构造时的函数 resolve() 和 reject() 来改变。</p> <p>如果 x 处于等待状态，那么 promise 继续保持等待状态，等待解决过程函数  resolvePromise() 执行，否则应该用相同的值执行或拒绝 promise。我们无法从外部拒绝或执行一个 Promise  实例，只能通过调用构造函数传入的 resolve() 和 reject() 函数来实现。所以还需要把这两个函数作为参数传递到  resolvePromise 函数中。</p> <p>在函数 resolvePromise() 内部加上情况 2 的判断，代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span><span class="token parameter">promise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">Promise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>state <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">reject</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再来实现情况 3，将 x.then 取出然后执行，并将执行结果放入解决过程函数  resolvePromise() 中。 考虑到 x 可能只是一个 thenable 而非真正的 Promise，所以在调用 then()  函数的时候要设置一个变量 excuted 避免重复调用。同时记得在执行时添加异常捕获并及时拒绝当前 promise。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> executed<span class="token punctuation">;</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> then <span class="token operator">=</span> x<span class="token punctuation">.</span>then<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> then <span class="token operator">===</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">then</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>executed<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        executed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">resolvePromise</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> y<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>executed<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
        executed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>executed<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    executed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>情况 4 就很简单了，直接把 x 作为值执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="promise-测试"><a href="#promise-测试" class="header-anchor">#</a> Promise 测试</h3> <p>编写测试代码永远是一个好习惯，为了验证编写的 Promise 正确性，引用一个专门用来测试 Promise 规范性的模块 <a href="https://github.com/promises-aplus/promises-tests" target="_blank" rel="noopener noreferrer">promises-aplus-tests<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，该模块内置了数百个测试案例，支持命令行一键测试。只是在导出模块的时候需要遵循 CommonJS 规范，并且按照要求导出对应的函数。<a href="https://github.com/yalishizhude/course/tree/master/plus2" target="_blank" rel="noopener noreferrer">最终代码地址请点击这里获取<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>测试结果如下图所示：</p> <p><img src="data:image/png;base64,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" alt="image (16).png"></p> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h3> <p>async 是 ES2017 标准推出的用于处理异步操作的关键字，从本质上来说，它就是 Generator 函数的语法糖。</p> <h4 id="什么是-generator-函数"><a href="#什么是-generator-函数" class="header-anchor">#</a> 什么是 Generator 函数？</h4> <p>Generator 函数是 ES6 提出的除 Promise 之外的另一种<strong>异步解决方案</strong>，不同于常见的异步回调，它的用法有些“奇怪”。这里我们只简单介绍一下它的主要用法。</p> <p>当声明一个 Generator 函数时，需要在 function 关键字与函数名之间加上一个星号，像下面这样：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当调用 Generator 函数后，函数并不会立即执行，而是返回一个迭代器对象。</p> <ul><li>函数体内部使用 yield 表达式，定义不同的内部状态。</li> <li>当函数体外部调用迭代器的 next() 函数时，函数会执行到下一个 yield 表达式的位置，并返回一个对象，该对象包含属性 value 和 done，value 是调用 next() 函数时传入的参数，done 为布尔值表示是否执行完成。</li></ul> <p>下面是一个将异步回调函数改写成 Generator 函数的示例代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token parameter">cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">asyncFn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>  <span class="token comment">// 1</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>下面讲讲这段代码的执行逻辑。</p> <ul><li>asyncFn() 是一个自定义的异步回调函数，1 秒后返回数值 1。</li> <li>先调用 Generator 函数得到迭代器 it，但此时函数并没有执行，需要执行迭代器的 next()  函数才能调用函数 fn() 。</li> <li>Generator 函数 fn() 内部调用异步函数 asyncFn 时使用了 yield 关键字，代表此处暂停执行，等到异步函数 asyncFn 执行完成后再执行后面的代码。</li> <li>1 秒后，匿名回调函数内部得到的返回值 1，通过 it.next() 函数返回这个值，并告诉迭代器继续执行后面的 console.log。</li></ul> <h4 id="async-await-原理"><a href="#async-await-原理" class="header-anchor">#</a> async/await 原理</h4> <p>虽然说 Generator 函数号称是解决异步回调问题，但却带来了一些麻烦，比如函数外部无法捕获异常，比如多个 yield 会导致调试困难。所以相较之下 Promise 是更优秀的异步解决方案。</p> <p>async/await 做的事情就是将 Generator 函数转换成 Promise。下面代码描述的是 async 的实现逻辑：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">generator2promise</span><span class="token punctuation">(</span><span class="token parameter">generatorFn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> gen <span class="token operator">=</span> <span class="token function">generatorFn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token keyword">var</span> info <span class="token operator">=</span> gen<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">var</span> value <span class="token operator">=</span> info<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>info<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">step</span><span class="token punctuation">(</span><span class="token string">&quot;next&quot;</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">step</span><span class="token punctuation">(</span><span class="token string">&quot;throw&quot;</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">return</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token string">&quot;next&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它将 Generator 函数包装成了一个新的匿名函数，调用这个匿名函数时返回一个  Promise。在这个  Promise 内部会创建一个 step() 函数，该函数负责递归调用 Generator  函数对应的迭代器，当迭代器执行完成时执行当前的 Promise，失败时则拒绝 Promise。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>本课时通过代码实例深入分析了 Promise/A+ 规范以及 async/await  的实现原理。对于手写 Promise 的过程，重点不在于实现结果，而在于实现过程，即先理解清楚规范，然后根据规范一步一步地去实现和优化。对于  async/await 语法糖，结合 Generator 函数，理解其封装原理即可。</p></div></div> <div class="side" data-v-3a89ef20><div data-v-3a89ef20><div style="margin-bottom: 50px" data-v-3a89ef20><h3 data-v-3a89ef20>关键词</h3> <div class="tagContainer" data-v-3a89ef20><span class="el-tag el-tag--info el-tag--plain" data-v-3a89ef20><a href="#promise-a-规范" data-v-3a89ef20>
                  Promise/A+ 规范
                </a></span><span class="el-tag el-tag--info el-tag--plain" data-v-3a89ef20><a href="#promise-实现" data-v-3a89ef20>
                  Promise 实现
                </a></span><span class="el-tag el-tag--info el-tag--plain" data-v-3a89ef20><a href="#promise-测试" data-v-3a89ef20>
                  Promise 测试
                </a></span><span class="el-tag el-tag--info el-tag--plain" data-v-3a89ef20><a href="#async-await" data-v-3a89ef20>
                  async/await
                </a></span><span class="el-tag el-tag--info el-tag--plain" data-v-3a89ef20><a href="#总结" data-v-3a89ef20>
                  总结
                </a></span></div></div></div> <div data-v-3a89ef20><h3 data-v-3a89ef20>相关文章</h3> <div class="sideItem" data-v-3a89ef20><a href="/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E5%8A%A0%E9%A4%902%EF%BC%9A%E6%89%8B%E5%86%99%20Promise%E3%80%81asyncawait.html" data-v-3a89ef20>
              加餐2：手写 Promise、async/await
            </a></div><div class="sideItem" data-v-3a89ef20><a href="/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E7%AC%AC12%E8%AE%B2%EF%BC%9A%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%20JavaScript%20%E4%BB%A3%E7%A0%81%EF%BC%9F.html" data-v-3a89ef20>
              第12讲：浏览器如何执行 JavaScript 代码？
            </a></div><div class="sideItem" data-v-3a89ef20><a href="/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E7%AC%AC14%E8%AE%B2%EF%BC%9AHTTP%20%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%AE%83%E7%9A%84%E2%80%9C%E8%A1%A5%E4%B8%81%E2%80%9D%E4%BB%AC.html" data-v-3a89ef20>
              第14讲：HTTP 协议和它的“补丁”们
            </a></div><div class="sideItem" data-v-3a89ef20><a href="/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E7%AC%AC13%E8%AE%B2%EF%BC%9A%E5%8C%BA%E5%88%86%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B.html" data-v-3a89ef20>
              第13讲：区分浏览器中的进程与线程
            </a></div><div class="sideItem" data-v-3a89ef20><a href="/%E5%89%8D%E7%AB%AF/%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E7%AC%AC15%E8%AE%B2%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9B%B4%E5%BF%AB%E5%9C%B0%E5%8A%A0%E8%BD%BD%E7%BD%91%E7%BB%9C%E8%B5%84%E6%BA%90%EF%BC%9F.html" data-v-3a89ef20>
              第15讲：如何让浏览器更快地加载网络资源？
            </a></div></div></div></div></div> <div class="footer-container" data-v-31e71e00 data-v-3a89ef20>
powered with ❤ by Bingordinary
</div></div></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.5d177364.js" defer></script><script src="/assets/js/7.65eecb72.js" defer></script><script src="/assets/js/2.aee3cbc0.js" defer></script><script src="/assets/js/14.10728167.js" defer></script>
  </body>
</html>
